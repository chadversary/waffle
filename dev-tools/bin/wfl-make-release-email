#!/bin/bash

: ${wfl_debug:=0}
if [[ "${#wfl_debug}" -gt 0 && "$wfl_debug" != 0 ]]; then
    set -vx
fi

set -o errexit
set -o nounset
set -o pipefail

declare -r prog="${0##*/}"

function wfl_print_opt_spec {
    cat <<-EOF
	$prog [-h|--help] <args>
	--
	  Required Arguments
	t,tag=tag           The git tag to release.

	  Optional Arguments
	h,help              Show this help message.
	sendmail-cmd=       Default is 'sendmail -t'.
	from=address        The value for the From: header. Defaults to "user.name <user.email>" from git-config.
	cc=address          Add a Cc: header. May occur multiple times.
	S,gpg-key=keyid     Specify non-default GPG signing key.
	gpg-opt=opt         Pass <opt> to gpg(1). May occur multiple times.
	run-unit-tests      Enabled by default.
	run-functional-tests  Enabled by default.
	EOF
}

function wfl_print_rel_email_header {
    cat <<-EOF
	Subject: [ANNOUNCE] Waffle $wfl_rel_version
	From: $arg_from
	To: waffle@lists.freedesktop.org
	EOF

    if [[ ${#arg_cc[@]} -gt 0 ]]; then
        printf 'Cc: %s\n' "${arg_cc[@]}"
    fi
}

function wfl_print_rel_email_body_common {
    cat <<-EOF
	Tarballs and other release files are published at

	    ${wfl_src_tar_xz_url}  SHA-256 ${wfl_src_tar_xz_sha256}
	    ${wfl_src_tar_sign_url}
	    ${wfl_armored_sha256sums_url}

	The signed git tag '${wfl_rel_tag}' is published in 

	    git://github.com/waffle-gl/waffle
	    http://github.com/waffle-gl/waffle
	    https://github.com/waffle-gl/waffle

	You can verify the release files by:

	    Verifying the tarball's signature:
	    xz -d ${wfl_src_tar_xz_basename} | gpg --verify ${wfl_src_tar_sign_basename}

	    Verifying the tag's signature:
	    git tag --verify ${wfl_rel_tag}

	    Verifying the tarball's checksum (least secure method):
	    echo '${wfl_src_tar_xz_sha256}  ${wfl_src_tar_xz_basename}' | sha256sum -c
	    
	Please file bugs and other issues at

	    ${wfl_issue_tracker_url}

	You can view the commit history for this release at

	    https://github.com/waffle-gl/waffle/commits/refs/tags/${wfl_rel_tag}

	You can track the release status at

	    ${wfl_release_tracker_url}

	EOF

    cat "$wfl_release_notes_path"
}

function wfl_print_rc_rel_email_body {
    echo "A release candidate Waffle ${wfl_rel_version} is now available for testing."
    echo
    wfl_print_rel_email_body_common
}

function wfl_print_feature_rel_email_body {
    echo "The feature release Waffle ${wfl_rel_version} is now available."
    echo
    wfl_print_rel_email_body_common
}

function wfl_print_maintenance_rel_email_body {
    local prev_version="${wfl_rel_major_version}.${wfl_rel_minor_version}.$((wfl_rel_patch_version - 1))"

    cat <<-EOF
	A maintenance release Waffle ${wfl_rel_version} is now available. This
	release fixes issues since Waffle ${prev_version}.

	EOF

    wfl_print_rel_email_body_common
}

function wfl_print_rel_email_body {
    wfl_print_${wfl_rel_type}_rel_email_body
}

function git_has_staged_changes {
    "$@" update-index -q --refresh
    "$@" diff-index --quiet --cached HEAD
}

function git_has_unstaged_changes {
    "$@" update-index -q --refresh
    "$@" diff-files --quiet
}

function git_has_untracked_files {
    local untracked_files= git_args=

    "$@" update-index -q --refresh
    git_args=("$@" 'ls-files' --others --exclude-standard --)
    if ! untracked_files="$("${git_args[@]}")"; then
        die "failed command: ${git_args[@]}"
    fi
    [[ -n "$untracked_files" ]]
}

function git_is_dirty {
    git_has_staged_changes "$@" ||
    git_has_unstaged_changes "$@" ||
    git_has_untracked_files
}

function wfl_git {
    git --git-dir="$wfl_git_dir" --work-tree="$wfl_git_work_tree" "$@"
}

function wfl_web_git {
    git --git-dir="$wfl_web_git_dir" --work-tree="$wfl_web_git_work_tree" "$@"
}

function wfl_gpg {
    local gpg_cmd=(gpg2 --digest-algo SHA256)

    if [[ -v arg_keyid ]]; then
        gpg_cmd+=(--default-key "$arg_keyid")
    fi

    if [[ ${#arg_gpg_opt[@]} -gt 0 ]]; then
        gpg_cmd+=("${arg_gpg_opt[@]}")
    fi

    "${gpg_cmd[@]}" "$@"
}

function die {
    printf '%s: error' "$prog"
    if [[ $# -gt 0 ]]; then
        printf ': %s' "$@"
    fi
    printf '\n'

    exit 1
}

function usage_error {
    echo "usage error: $@"
    parse_args --help
}

function wfl_prompt_yes_no {
    while true; do
        declare -l choice=

        read -r -n1 -p "> $@ [Y/n] " choice
        if ! [[ "$choice" ]]; then
            choice="y"
        fi

        case "$choice" in
            y) return 0;;
            n) return 1;;
            *) continue;;
        esac
    done
}

function wfl_prompt_pause {
    while true; do
        read -r -n1 -p "> $@ [any key to continue]"
    done
}

function parse_args {
    arg_cc=('')
    arg_gpg_opt=('')

    eval "$(wfl_print_opt_spec | git rev-parse --parseopt -- "$@" || echo "exit $?")"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --)
                shift
                break
                ;;
            --cc)
                arg_cc+=("$2")
                shift 2
                ;;
            -t|--tag)
                if [[ -v arg_tag ]]; then
                    usage_error 'multiple occurences of argument <tag>'
                fi
                arg_tag="$2"
                shift 2
                ;;
            --from)
                if [[ -v arg_from ]]; then
                    usage_error 'multiple occurences of argument <from>'
                fi
                arg_from="$2"
                shift 2
                ;;
            --gpg-opt)
                arg_gpg_opt+=("$2")
                shift 2
                ;;
            -S|--gpg-key)
                if [[ -v arg_keyid ]]; then
                    usage_error 'multiple occurences of argument <keyid>'
                fi
                arg_keyid="$2"
                shift 2
                ;;
            --run-unit-tests|--no-run-unit-tests)
                if [[ -v arg_run_unit_tests ]]; then
                    usage_error 'multiple occurences of <run-unit-tests>'
                fi

                if [[ "$1" = --no-* ]]; then
                    arg_run_unit_tests=
                else
                    arg_run_unit_tests=1
                fi

                shift 1
                ;;
            --run-functional-tests|--no-run-functional-tests)
                if [[ -v arg_run_functional_tests ]]; then
                    usage_error 'multiple occurences of <run-functional-tests>'
                fi

                if [[ "$1" = --no-* ]]; then
                    arg_run_functional_tests=
                else
                    arg_run_functional_tests=1
                fi

                shift 1
                ;;
            --sendmail-cmd)
                if [[ -v arg_sendmail_cmd ]]; then
                    usage_error 'multiple occurences of <sendmail-cmd>'
                fi
                arg_sendmail_cmd="$1"
                shift 1
                ;;
            *)
                internal_error
                ;;
        esac
    done

    if [[ $# -gt 0 ]]; then
        usage_error "trailing args: $@"
    fi

    if [[ ! -v arg_tag ]]; then
        usage_error "missing required argument <tag>"
    fi

    if ! [[ "$arg_tag" =~ v[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+(-rc[[:digit:]]+)?$ ]]; then
        usage_error "argument tag='$arg_tag' does not look like a version tag"
    fi

    if [[ -v arg_from ]]; then
        :
    elif [[ -v wfl_git_user_name && -v wfl_git_user_email ]]; then
        arg_from="$wfl_git_user_name <$wfl_git_user_email>"
    elif [[ -v wfl_git_user_email ]]; then
        arg_from="$wfl_git_user_email"
    elif [[ -v EMAIL ]]; then
        arg_from="$EMAIL"
    else
        usage_error 'if argument <from> is missing, then either user.email' \
                    'in the git config or the environment variable EMAIL' \
                    'must be set'
    fi

    # Remove dummy head elements.
    arg_cc=("${arg_cc[@]:1}")
    arg_gpg_opt=("${arg_gpg_opt[@]:1}")

    # Set default values.
    : ${arg_sendmail_cmd:=sendmail -t}
    : ${arg_run_unit_tests:=}
    : ${arg_run_functional_tests:=}
}

function wfl_make_tmp_dir {
    tmp_dir="$(mktemp -d "/tmp/${prog}.XXXXXX"})"
    echo "$prog: info: temporary directory created: $tmp_dir"
}

function wfl_check_local_git_repos_are_clean {
    if git_is_dirty wfl_git; then
        die "git repo is dirty: $wfl_git_dir"
    fi

    if git_is_dirty wfl_web_git; then
        die "git repo is dirty: $wfl_web_git_dir"
    fi
}

function wfl_pre_inspect_local_git {
    if [[ "$(wfl_git log master..maint)" ]]; then
        die "The 'master' branch is not a superset of 'maint'." \
            "Checkout 'master', merge 'maint' into it, and try again."
    fi

    wfl_git log --graph --decorate --stat | less
    wfl_prompt_yes_no "Does the waffle git look good?"

    $wfl_git_editor "$wfl_release_notes_path"
    wfl_prompt_yes_no "Do the raw release notes look good?"
}

function wfl_web_pre_inspect_local_git {
    wfl_git log --graph --decorate --stat | less
    wfl_prompt_yes_no "Does the waffle-web git log look good?"
}

function wfl_get_git_info {
    wfl_git_dir="$(git rev-parse --git-dir)"
    wfl_git_work_tree="$(wfl_git rev-parse --show-toplevel)"
    wfl_git_editor="$(wfl_git var GIT_EDITOR)"
    wfl_git_user_name="$(wfl_git config user.name)" || unset wfl_git_user_name
    wfl_git_user_email="$(wfl_git config user.email)" || unset wfl_git_user_email

    wfl_web_git_dir="$arg_web_git_dir"
    wfl_web_git_work_tree="$(wfl_web_git rev-parse --show-toplevel)"
}

function wfl_get_rel_info {
    wfl_rel_tag="$arg_tag"
    wfl_rel_version="${wfl_rel_tag#v}"
    wfl_rel_name="waffle-${wfl_rel_version}"
    IFS='.-' read -r wfl_rel_major_version \
                    wfl_rel_minor_version \
                    wfl_rel_patch_version \
                    wfl_rel_rc_version \
                    <<< "$wfl_rel_version"
    wfl_rel_rc_version="${wfl_rel_rc_version#rc}" # Strip 'rc' to get just the integer path.
    wfl_rel_version_stable_part="${wfl_rel_major_version}.${wfl_rel_minor_version}.${wfl_rel_patch_version}"
    wfl_release_notes_path="$wfl_git_work_tree/doc/release-notes/waffle-${wfl_rel_version_stable_part}.txt"


    if [[ -n "$wfl_rel_rc_version" ]]; then
        wfl_rel_type='rc'
    elif [[ "$wfl_patch_version" -eq 0 ]]; then
        wfl_rel_type='feature'
    else
        wfl_rel_type='maintenance'
    fi
}

function wfl_get_rel_basenames {
    wfl_src_tar_basename="${wfl_rel_name}.tar"
    wfl_src_tar_sign_basename="${wfl_src_tar_basename}.asc"
    wfl_src_tar_xz_basename="${wfl_src_tar_basename}.xz"
    wfl_sha256sums_basename="${wfl_rel_name}.sha256sums"
    wfl_armored_sha256sums_basename="${wfl_sha256sums_basename}.asc"
    wfl_rel_email_basename="${wfl_rel_name}.eml"
}

function wfl_get_rel_paths {
    wfl_src_tar_path="$tmp_dir/$wfl_src_tar_basename"
    wfl_src_tar_xz_path="$tmp_dir/$wfl_src_tar_xz_basename"
    wfl_src_tar_sign_path="$tmp_dir/$wfl_src_tar_sign_basename"
    wfl_sha256sums_path="$tmp_dir/$wfl_sha256sums_basename"
    wfl_armored_sha256sums_path="$tmp_dir/$wfl_armored_sha256sums_basename"
    wfl_rel_email_path="$tmp_dir/$wfl_rel_email_basename"

    wfl_tmp_src_dir="$tmp_dir/$wfl_rel_name"
    wfl_tmp_build_dir="$wfl_tmp_src_dir"
    wfl_tmp_prefix="$tmp_dir/prefix"
|

function wfl_get_rel_urls {
    wfl_release_tracker_url="https://github.com/waffle-gl/waffle/milestones"
    wfl_issue_tracker_url="https://github.com/waffle-gl/waffle/issues"

    wfl_url_host="www.waffle-gl.org"
    wfl_site_url="http://${wfl_url_host}"

    wfl_src_tar_xz_url_path="files/release/${wfl_rel_name}/${wfl_src_tar_xz_basename}"
    wfl_src_tar_sign_url_path="files/release/${wfl_rel_name}/${wfl_src_tar_sign_basename}"
    wfl_rel_email_url_path="files/release/${wfl_rel_name}/${wfl_rel_email_basename}"
    wfl_armored_sha256sums_url_path="files/release/${wfl_rel_name}/${wfl_armored_sha256sums_basename}"

    wfl_src_tar_xz_url="${wfl_site_url}/${wfl_src_tar_xz_url_path}"
    wfl_src_tar_sign_url="${wfl_site_url}/${wfl_src_tar_sign_url_path}"
    wfl_rel_email_url="${wfl_site_url}/${wfl_rel_email_url_path}"
    wfl_armored_sha256sums_url="${wfl_site_url}/${wfl_armored_sha256sums_url_path}"
}

function wfl_update_local_git {
    wfl_git log --graph --decorate --stat | less
    wfl_prompt_yes_no "Does log look good?"

    $wfl_git_editor "$wfl_release_notes_path"
    wfl_prompt_yes_no "Do release notes look good?"

    wfl_prompt_yes_no "Proceed to locally tag '$wfl_rel_tag'?"
    wfl_git tag -s -m "Waffle $wfl_rel_version" "$wfl_rel_tag"
    wfl_rel_tag_sha1=$(git rev-parse $wfl_rel_tag)
}

function wfl_make_rel_tarballs {
    wfl_git archive \
        --output="$wfl_src_tar_path" \
        --prefix="$wfl_rel_name/" \
        "$wfl_rel_tag"
    wfl_gpg --armor --detach-sign "$wfl_src_tar_path"
    xz --keep "$wfl_src_tar_path" > "$wfl_src_tar_xz_path"

    wfl_src_tar_xz_sha256="$(sha256sum "$wfl_src_tar_xz_path" | cut -f 1 -d ' ')"
    echo "$wfl_src_tar_xz_sha256  $wfl_src_tar_xz_basename" > "$wfl_sha256sums_path"
    wfl_gpg --armor "$wfl_sha256sums_path" > "$wfl_armored_sha256sums_path"
}

function wfl_make_rel_email {
    wfl_print_rel_email_body > "$wfl_rel_email_path"

    # Give user an opportunity to edit the email.
    "$wfl_git_editor" "$wfl_rel_email_path"

    mv "$wfl_rel_email_path" "${wfl_rel_email_path}.tmp"
    {
        wfl_print_rel_email_header
        echo 
        wfl_gpg --stdout --armor "${wfl_rel_email_path}.tmp"
    } > "$wfl_rel_email_path"

    # The email is now signed, so don't alter it.
    chmod -w "$wfl_rel_email_path"

    # Give user an opportunity to review the email after gpg wraps it in armor,
    # just in case the GPG armor mangled the formatting.
    "$wfl_git_editor" "$wfl_rel_email_path"

    wfl_prompt_yes_no 'Does the email look good?'

}

function wfl_configure_build_install {
    local cmake_args=(
        "-DCMAKE_BUILD_TYPE=Release"
        "-DCMAKE_INSTALL_PREFIX=$wfl_tmp_prefix"
        "-Dwaffle_build_examples=1"
        "-Dwaffle_build_manpages=1"
        "-Dwaffle_build_htmldocs=1"
        "-H$wfl_tmp_src_dir"
        "-B$wfl_tmp_build_dir"
    )

    tar -C "$tmp_dir" -xf "$wfl_src_tar_basename"
    cmake "${cmake_args[@]}"
    make -j4 -C "$wfl_tmp_build_dir"

    if [[ "$arg_run_unit_tests" ]]; then
        make -j4 -C "$wfl_tmp_build_dir" check
    fi

    if [[ "$arg_run_functional_tests" ]]; then
        make -j4 -C "$wfl_tmp_build_dir" check-func
    fi

    make -C "$wfl_tmp_build_dir" install
}

function wfl_web_update_local_git {
    local old_head=
    old_head="$(wfl_git rev-parse HEAD)"

    # Update manpages.
    rsync --verbose --archive --delete \
        "$wfl_tmp_prefix/$wfl_doc_dir/html/man/" \
        "$wfl_web_work_tree/man/"
    wfl_web_git add -A
    wfl_web_git diff -M --stat --cached | less
    wfl_prompt_yes_no "Proceed to commit message?"
    wfl_web_git commit -s --edit -m "man: Update manpages for Waffle $wfl_rel_tag"

    # Update release files.
    local stem=
    for stem in wfl_release_notes \
                wfl_src_tar_xz \
                wfl_src_tar_sign \
                wfl_armored_sha256sums; do
        eval "cp -T '${stem}_path' '$wfl_web_git_work_tree/${stem}_url_path'"
    done

    {
        cat <<-EOF
	Paste the html code below into "${wfl_web_git_work_tree}/releases.html".

	You are in 'less'. Press 'q' to quit.

	      <li><a name="${wfl_rel_version}" href="#${wfl_rel_version}"><h3>${wfl_rel_version}</h3></a>
	        <ul>
	          <li>Date: $(date --utc --rfc-3339=date)</li>
	          <li><a href="${wfl_release_notes_url_path}">Release Notes</a></li>
	          <li><a href="${wfl_src_tar_xz_url_path}">${wfl_src_tar_xz_basename}</a></li>
	          <li><a href="${wfl_src_tar_sign_url_path}">${wfl_src_tar_sign_basename}</a></li>
	          <li><a href="${wfl_armored_sha256sums_url_path}" type="text/plain">${wfl_armored_sha256sums_basename}</a></li>
	        </ul>
	      </li>
	EOF
    } | less

    wfl_web_git add -A
    wfl_web_git diff -M --stat --cached | less
    wfl_prompt_yes_no "Proceed to commit message?"
    wfl_web_git commit -s --edit -m "releases: Add release artififacts for Waffle $wfl_rel_version"

    wfl_web_git log --stat --patch "${old_head}..HEAD"
    wfl_prompt_yes_no "Proceed to locally tag '$wfl_rel_tag'?"
    wfl_web_git tag -s -m "Waffle $waffle_rel_version" "$wfl_rel_tag"
}

function wfl_update_remote_git {
    local refs_to_push=('')

    wfl_git log --stat --patch "${old_head}..HEAD" | less

    if wfl_prompt_yes_no "Push tag '$wfl_rel_tag' to remote 'origin'?"; then
        refs_to_push+=($wfl_rel_tag)
    fi

    case "$wfl_rel_type" in
        rc|feature)
            if wfl_prompt_yes_no "Push branch 'master' to 'origin'?"; then
                refs_to_push+=('master')
            fi
            ;;
        maintenance)
            local maint_sha1=
            local maint_versioned_branch="maint-${wfl_rel_major_version}.${wfl_rel_minor_version}"
            local maint_versioned_sha1=
                
            if ! maint_sha1=$(wfl_git rev-parse maint --) \
               && wfl_prompt_yes_no "Create local branch 'maint' from tag '$wfl_rel_tag'?"; then
                wfl_git branch maint $wfl_rel_tag
                maint_sha1=$(wfl_git rev-parse maint --)
            fi

            if ! maint_versioned_sha1=$(wfl_git rev-parse $maint_versioned_branch --) \
               && wfl_prompt_yes_no "Create local branch '$maint_versioned_branch' from tag '$wfl_rel_tag'?"; then
                wfl_git branch $maint_versioned_branch $wfl_rel_tag
                maint_versioned_sha1=$(wfl_git rev-parse $maint_versioned_branch --)
            fi

            if [[ "$maint_versioned_sha1" = "$wfl_rel_tag_sha1" ]]; then
               wfl_prompt_yes_no "Push branch '$maint_versioned_branch' to 'origin'?"; then
               refs_to_push+=("$maint_versioned_branch")
            fi
            ;;
        *)
            internal_error
            ;;
    esac

    # Remove initial dummy element.
    refs_to_push="${refs_to_push[@]:1}"

    if [[ ${#refs_to_push[@]} -gt 0 ]]; then
        wfl_git push "origin" "${refs_to_push[@]}"
    fi
}

function wfl_web_update_remote_git {
    local refs_to_push=('')

    wfl_web_git log --stat --patch "${old_head}..HEAD" | less

    if wfl_prompt_yes_no "Push tag '$wfl_rel_tag' to remote 'origin'?"; then
        refs_to_push+=($wfl_rel_tag)
    fi

    if wfl_prompt_yes_no "Push branch 'master' to 'origin'?"; then
        refs_to_push+=('master')
    fi

    # Remove initial dummy element.
    refs_to_push="${refs_to_push[@]:1}"

    if [[ ${#refs_to_push[@]} -gt 0 ]]; then
        wfl_web_git push "origin" "${refs_to_push[@]}"
    fi
}

function wfl_send_release_email {
    if wfl_prompt_yes_no "Review the release announcement?"; then
        $wfl_git_editor "$wfl_rel_email_path"
    fi

    if ! wfl_prompt_yes_no "Send the announcement?"; then
        return 0
    fi
    
    local sendmail_cmd=
    read -r -p "> Enter sendmail command [default='$arg_sendmail_cmd']: " sendmail_cmd
    if [[ -z "$sendmail_cmd" ]]; then
        sendmail_cmd="$arg_sendmail_cmd"
    fi

    $sendmail_cmd < "$wfl_rel_email_path"
}

wfl_get_git_info

parse_args "$@"

wfl_check_local_git_repos_are_clean
wfl_pre_inspect_local_git
wfl_web_pre_inspect_local_git

wfl_make_tmp_dir

wfl_get_rel_info
wfl_get_rel_paths
wfl_get_rel_urls

# Next we begin writing to the git repos. Be nice, and provide cleanup hints on
# abrupt failures.
trap "{
    cat <<-EOF
	$prog: exiting on error ...
	You should inspect the logs for the following repos:
	    $wfl_git_dir
	    $wfl_web_git_dir
	EOF;
}" ERR

wfl_prompt_pause "Begin preparing the release locally..."
wfl_update_local_git
wfl_make_rel_tarballs
wfl_configure_build_install
wfl_make_rel_email
wfl_web_update_local_git
wfl_prompt_pause "Successfully prepared the release locally."

wfl_prompt_pause "Begin interactively publishing changes..."
wfl_update_remote_git
wfl_web_update_remote_git
wfl_prompt_pause "Done publishing changes."

wfl_send_release_email

# Give final hints.
cat <<-EOF
	Script is done.

	Next steps:
	    1. Cleanup the temporary directory: $tmp_dir
	    2. Update release tracker: $wfl_release_tracker_url
	    3. Inspect the issue tracker: $wfl_issue_tracker_url
	EOF
